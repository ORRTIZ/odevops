/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import org.apache.tools.ant.filters.ReplaceTokens

/* ========================================================
 * Project setup
 * ======================================================== */

apply plugin: 'java'
apply plugin: 'eclipse'

apply from: 'common.gradle'
apply from: 'tools/*.gradle'

// operating system property
ext.os = System.getProperty('os.name').toLowerCase()

// java settings
def jvmArguments = ['-Xms128M', '-Xmx1024M',
    "-javaagent:${rootDir}/tools/security/notsoserial/notsoserial-1.0-SNAPSHOT.jar",
    "-Dnotsoserial.whitelist=${rootDir}/tools/security/notsoserial/empty.txt",
    "-Dnotsoserial.dryrun=${rootDir}/tools/security/notsoserial/is-deserialized.txt",
    "-Dnotsoserial.trace=${rootDir}/tools/security/notsoserial/deserialize-trace.txt"]
ext.ofbizMainClass = 'org.apache.ofbiz.base.start.Start'
javadoc.failOnError = false
sourceCompatibility = '1.8'
targetCompatibility = '1.8'

// root and subproject settings
defaultTasks 'build'

allprojects {
    repositories{
        jcenter()
    }
}

subprojects {
    configurations {
        // compile-time plugin libraries
        pluginLibsCompile
        // runtime plugin libraries
        pluginLibsRuntime
    }
}

configurations {
    junitLibs
}

sourceSets {
    main {
        java {
            srcDirs = getDirectoryInActiveComponentsIfExists('src/main/java')
            exclude excludedJavaSources
        }
        resources {
            srcDirs = getDirectoryInActiveComponentsIfExists('src/main/java')
            srcDirs += getDirectoryInActiveComponentsIfExists('config')
            exclude excludedJavaSources
        }
    }

    test {
        java {
            srcDirs = getDirectoryInActiveComponentsIfExists('src/test/java')
        }
        resources {
            srcDirs = getDirectoryInActiveComponentsIfExists('src/test/java')
        }
    }
}

jar {
    manifest {
        attributes(
            "Implementation-Title": project.name,
            "Main-Class": ofbizMainClass,
            "Class-Path": getJarManifestClasspathForCurrentOs()
        )
    }
}


/* ========================================================
 * Tasks
 * ======================================================== */

// ========== Task group labels ==========
def cleanupGroup = 'Cleaning'
def ofbizServer = 'OFBiz Server'

// ========== OFBiz Server tasks ==========


task terminateOfbiz(group: ofbizServer,
    description: 'Force termination of any running OFBiz servers, only use if \"--shutdown\" command fails') << {
    if (os.contains('windows')) {
        Runtime.getRuntime().exec("wmic process where \"CommandLine Like \'%org.apache.ofbiz.base.start.Start%\'\" Call Terminate")
    } else {
        def processOutput = new ByteArrayOutputStream()
        exec {
            commandLine 'ps', 'ax'
            standardOutput = processOutput
        }
        processOutput.toString().split(System.lineSeparator()).each { line ->
            if(line ==~ /.*org\.apache\.ofbiz\.base\.start\.Start.*/) {
                exec { commandLine 'kill', '-9', line.tokenize().first() }
            }
        }
    }
}

// ========== System Administration tasks ==========

/*
 * TODO replace this code with something more declarative.
 * We are using it so that if tests fail we still get HTML reports
 */
gradle.taskGraph.afterTask { Task task, TaskState state ->
    if (task.name ==~ /^ofbiz.*--test.*/
        || task.name ==~ /^ofbiz.*-t.*/) {
        tasks.createTestReports.execute()
    }
}

// ========== Clean up tasks ==========
task cleanCatalina(group: cleanupGroup, description: 'Clean Catalina data in runtime/catalina/work') << {
    delete "${rootDir}/runtime/catalina/work"
}
task cleanData(group: cleanupGroup, description: 'Clean all DB data (Derby) under runtime/data') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/data/", ['README', 'derby.properties'])
}
task cleanDownloads(group: cleanupGroup, description: 'Clean all downloaded files') << {
    delete fileTree(dir: "${rootDir}/framework/base/lib", includes: ['activemq-*.jar'])
    delete fileTree(dir: "${rootDir}/framework/entity/lib/jdbc", includes: ['postgresql-*.jar'])
    delete fileTree(dir: "${rootDir}/framework/entity/lib/jdbc", includes: ['mysql-*.jar'])
}
task cleanLogs(group: cleanupGroup, description: 'Clean all logs in runtime/logs') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/logs/", ['README'])
}
task cleanOutput(group: cleanupGroup, description: 'Clean runtime/output directory') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/output/", ['README'])
}
task cleanIndexes(group: cleanupGroup, description: 'Remove search indexes (e.g. Lucene) from runtime/indexes') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/indexes/", ['README', 'index.properties'])
}
task cleanTempfiles(group: cleanupGroup, description: 'Remove file in runtime/tempfiles') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/tempfiles/", ['README'])
    deleteAllInDirWithExclusions("${rootDir}/runtime/tmp/", ['README'])
}
task cleanUploads(group: cleanupGroup, description: 'Remove uploaded files.') << {
    deleteAllInDirWithExclusions("${rootDir}/runtime/uploads/", [])
}
task cleanXtra(group: cleanupGroup, description: 'Clean extra generated files like .rej, .DS_Store, etc.') << {
    delete fileTree(dir: "${rootDir}", includes: ['**/.nbattrs', '**/*~','**/.#*', '**/.DS_Store', '**/*.rej', '**/*.orig'])
}
task cleanGradle(group: cleanupGroup, description: 'clean generated files from Gradle') << {
    delete file("${rootDir}/.gradle")
}
task cleanAnt(group: cleanupGroup, type: Delete, description: "clean old artifacts generated by Ant") {
    /* TODO this task is temporary and should be deleted after some
     * time when users have updated their trees. */
    ['framework', 'specialpurpose', 'applications'].each { componentGroup ->
        file(componentGroup).eachDir { component ->
            delete file(component.toString() + '/build')
        }
    }
    delete 'ofbiz.jar'
}

/*
 * Keep this task below all other clean tasks  The location of
 * declaration is important because it means that it will automatically
 * run whenever the task cleanAll executes (dependency matched by regex)
 */
def cleanTasks = getTasksMatchingRegex(/^clean.+/)
task cleanAll(group: cleanupGroup, dependsOn: [cleanTasks, clean]) {
    description 'Execute all cleaning tasks.'
}



// ========== hidden support tasks ==========

/* without executing this task, a test would fail that is named
 * org.apache.ofbiz.base.util.test.UtilObjectTests.testGetObjectFromFactory()
 *
 * The test fails because it requires defining a service provider, read more below.
 * http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider
 */
task createBaseTestServiceProviderJar << {
    ant.jar(destfile: "${rootDir}/build/libs/ofbiz-base-test.jar") {
        service(type: 'org.apache.ofbiz.base.util.test.UtilObjectTests$TestFactoryIntf') {
            provider(classname: 'org.apache.ofbiz.base.util.test.UtilObjectTests$FirstTestFactory')
            provider(classname: 'org.apache.ofbiz.base.util.test.UtilObjectTests$SecondTestFactory')
        }
    }
}
classes.dependsOn createBaseTestServiceProviderJar

/* ========================================================
 * Rules-based OFBiz server commands
 * ======================================================== */

tasks.addRule('Pattern: ofbiz <Commands>: Execute OFBiz startup commands') { String taskName ->
    if(taskName ==~ /^ofbiz\s.*/ || taskName == 'ofbiz') {
        def arguments = (taskName - 'ofbiz').toLowerCase().tokenize(' ')
        createOfbizCommandTask(taskName, arguments, jvmArguments, false)
    }
}

tasks.addRule('Pattern: ofbizDebug <Commands>: Execute OFBiz startup commands in remote debug mode') { String taskName ->
    if(taskName ==~ /^ofbizDebug\s.*/ || taskName == 'ofbizDebug') {
        def arguments = (taskName - 'ofbizDebug').toLowerCase().tokenize(' ')
        createOfbizCommandTask(taskName, arguments, jvmArguments, true)
    }
}

tasks.addRule('Pattern: ofbizBackground <Commands>: Execute OFBiz startup commands in background and output to console.log') { String taskName ->
    if(taskName ==~ /^ofbizBackground\s.*/ || taskName == 'ofbizBackground') {
        createOfbizBackgroundCommandTask(taskName)
    }
}

/* ========================================================
 * Helper Functions
 * ======================================================== */

def createOfbizCommandTask(taskName, arguments, jvmArguments, isDebugMode) {

    def ofbizJarName = buildDir.toString()+'/libs/'+project.name+'.jar'

    task(type: JavaExec, dependsOn: build, taskName) {
        jvmArgs(jvmArguments)
        debug = isDebugMode
        classpath = files(ofbizJarName)
        main = ofbizMainClass
        arguments.each { argument ->
            args argument
        }
    }
}

def createOfbizBackgroundCommandTask(taskName) {
    def sourceTask = taskName.tokenize().first()
    def arguments = (taskName - sourceTask)

    def gradleRunner = os.contains('windows') ? 'gradlew.bat' : './gradlew'

    task (taskName) {
        doLast {
            spawnProcess(gradleRunner, "ofbiz ${arguments}")
        }
    }
}

def spawnProcess(command, arguments) {
    ProcessBuilder pb = new ProcessBuilder(command, arguments)
    File consoleLog = file("${rootDir}/runtime/logs/console.log");

    pb.directory(file("${rootDir}"))
    pb.redirectErrorStream(true)
    pb.redirectOutput(ProcessBuilder.Redirect.appendTo(consoleLog))
    pb.start()
}

def getDirectoryInActiveComponentsIfExists(String dirName) {
    def dirInComponents = []
    iterateOverActiveComponents { component ->
        def subDir = file(component.toString() + '/' + dirName)
        if(subDir.exists()) {
            dirInComponents.add subDir
        }
    }
    return dirInComponents
}

def deleteAllInDirWithExclusions(dirName, exclusions) {
    ant.delete (includeEmptyDirs: 'true', verbose: 'on') {
        fileset(dir: dirName, includes: '**/*', erroronmissingdir: "false") {
            exclusions.each { exclusion ->
                exclude name: exclusion
            }
        }
    }
}

def getTasksMatchingRegex(theRegex) {
    def filteredTasks = []
    tasks.each { task ->
        if(task.name ==~ theRegex) {
            filteredTasks.add(task)
        }
    }
    return filteredTasks
}

def generateFileFromTemplate(templateFileInFullPath, targetDirectory, filterTokens, newFileName) {
    copy {
        from (templateFileInFullPath) {
            filter ReplaceTokens, tokens: filterTokens
            rename templateFileInFullPath.tokenize('/').last(), newFileName
        }
        into targetDirectory
    }
}

def getJarManifestClasspathForCurrentOs() {
    def osClassPath = ''
    if(os.contains('windows')) {
        configurations.runtime.files.each { cpEntry ->
            osClassPath += '\\' + cpEntry.toString() + ' '
        }
    } else {
        osClassPath = configurations.runtime.files.collect { "$it" }.join(' ')
    }
    return osClassPath
}
